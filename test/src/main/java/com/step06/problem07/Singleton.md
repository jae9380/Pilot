# Singleton

프로그램을 개발하다 보면 **단 하나의 객체만 존재해야 하는 상황**이 종종 생긴다.

> **그런데 왜 꼭 하나여야 할까?**

이유를 쉽고 익숙한 예로 살펴보자.

- **학급**에서 학생 관리의 책임자는 ‘반장’ 한 명이다.
- **조직**의 의사결정을 총괄하는 최고경영자(CEO)도 한 명뿐이다.

만약 반장이나 CEO가 둘 이상이라면 의사결정이 충돌해 혼란이 발생한다.  
프로그래밍도 마찬가지다. 시스템 전체에서 **중앙에서 관리해야 하는 역할**이 있으면 그 객체는 반드시 하나로 유지돼야 한다. 이렇게 **객체 생성을 한 번으로 제한**하는 설계가 바로 *싱글톤 패턴*이다.

다시 본론으로 넘어와서 싱글톤을 만들려면 클래스 외부에서 `new 연산자`로 생성자를 호출할 수 없도록 막아야 한다. 그 이유는 생성자를 호출한 만큼 객체가 생성되기 때문이다.  생성자를 외부에서 호출할 수 없도록 하기 위해서 생성자 앞에 `private` 접근 제어자를 사용한다.

그리고 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성하여 초기화를 한다. 참고로 클래스 내부에서는 `new 연산자`로 생성자 호출이 가능하다.

정적 필드로 `private` 접근 제어자를 붙여 외부에서 값을 함부로 변경하지 못 하도록 막는다. 대신 외부에서 호출할 수 있는 정적 메서드 `getInstance()`를 선언하여 정적 필드에서 참조하고 있는 자신 객체를 리턴해준다.

```java
public class 클래스 {
	// 정적 필드
	private static 클래스 singleton = new 클래스();

	// 생성자
	private 클래스() {}

	// 정적 메서드
	static 클래스 getInstance() {
		return singleton;
	}
}
```

이제 외부에서 객체를 얻는 유일한 방법은 정적 메서드를 호출하는 방법이다.

```java
클래스 변수1 = 클래스.getInstance();
클래스 변수2 = 클래스.getInstance();
```

위 처럼 클래스의 정적 메서드를 이용하여 객체를 얻을 경우 변수1 과 변수2는 동일한 객체를 참조하게 된다. 