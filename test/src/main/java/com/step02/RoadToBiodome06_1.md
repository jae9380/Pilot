_두 정수 배열이 주어지는 상황에서 하나의 배열로 병합하지 않고 중앙값을 추출하는 과정에 대한 설명이다._

## 전체적인 코드    


```java
    public static double findMedian(int[] arr1, int[] arr2, boolean isItBonus) {
        if (!isItBonus && arr1.length > arr2.length) return findMedian(arr2, arr1, false); // 더 짧은 배열을 기준으로 이진탐색 진행하기 위함

        if (isItBonus) {
            if (arr1.length > arr2.length) return findMedian(arr2, arr1, true);
            arr1 = filterOver30(arr1);
            arr2 = filterOver30(arr2);
        }

        int n = arr1.length, m = arr2.length;
        int iMin = 0, iMax = n, halfLen = (n + m + 1) / 2;

        int count = 0;
        while (iMin <= iMax) {
            int i = (iMin + iMax) / 2;
            int j = halfLen - i;

            if (i < n && arr2[j - 1] > arr1[i]) {
                iMin = i + 1;
            } else if (i > 0 && arr1[i - 1] > arr2[j]) {
                iMax = i - 1;
            } else {
                int maxOfLeft;
                if (i == 0) maxOfLeft = arr2[j - 1];
                else if (j == 0) maxOfLeft = arr1[i - 1];
                else maxOfLeft = Math.max(arr1[i - 1], arr2[j - 1]);

                if ((n + m) % 2 == 1) return maxOfLeft;
             
                int minOfRight;
                if (i == n) minOfRight = arr2[j];
                else if (j == m) minOfRight = arr1[i];
                else minOfRight = Math.min(arr1[i], arr2[j]);

                return (maxOfLeft + minOfRight) / 2.0;
            }
        }

        throw new IllegalArgumentException("Input arrays are not sorted.");
    }
```    

---

## 설명

일단 당연하게 두 배열을 이용하기 위해 매개값으로 정수 배열 두 개를 받아온다. 여기서 첫 배열의 길이가 짧은 배열이 오도록 하기 위해서 메서드 시작 부분에 조건문을 사용해서 최초의 호출에서 길이가 긴 배열이 처음에 오는 상황을 생각해서 다시 호출하도록 했다.

> #### 그런데 왜 길이가 짧은 배열이 앞에 와야 하는가?
	중간값을 구하는 알고리즘으로 이진탐색을 사용했기 때문이다. 그렇기 때문에 빠르게 값을 구하기 위해서 길이가 짧은 배열을 기준하여 연산하도록 했다.

```java
        if (!isItBonus && arr1.length > arr2.length) return findMedian(arr2, arr1, false); // 더 짧은 배열을 기준으로 이진탐색 진행하기 위함
```

두 배열을 인덱스별로 관리하기 위해서 변수 `i`, `j`를 선언하였다. 
```java
            int i = (iMin + iMax) / 2;
            int j = halfLen - i;
```
각 변수의 초기화값이 `(iMin + iMax) / 2`, `halfLen - i`이다. 그 이유는 이진 탐색 알고리즘의 탐색은 중간 값을 시작으로 위치를 조정하기 때문에 `i`는 해당 배열의 중간 인덱스의 값을 주었으며, `j`는 `halfLen - i`의 값을 주었다.     

> #### 그런데 왜 `j`는 전체 배열의 길이에서 왜 `i`를 뺀 값을 주었는가?

두 배열을 하나의 배열로 만들어서 중간값을 구한다면 그냥 전체 배열에서 중간 부분의 값을 뽑으면 쉽다. 하지만 지금은 하나의 배열로 만들지 않기 떄문에 주어지는 두 배열에서 가상의 파티션을 만들어서 중간에 위치할 값을 고르기 위함이다.     

다시 설명을 하면, 주어지는 두 배열을 일단 하나의 배열로 병합을 하고, 해당 배열을 중간을 기준으로 왼쪽 절반과 오른쪽 절반으로 나누었다고 생각을 하자. 
그러면 중간값은 왼쪽 절반의 최대값과 오른쪽 절반의 최소값을 이용하면 중간값을 쉽게 찾을 수 있을 것이다.   

그렇기 때문에 `i + j = halfLen`이 되어야 한다. 

### 간단한 예시
  ```java
  int[] arr1 = {1, 3};
  int[] arr2 = {2, 4, 5, 6};
  
  // arr1, arr2 두 배열이 존재할 때 
  
  int halfLen = (n + m + 1) / 2; // (2 + 4 + 1) / 2 = 3
  ```

| **i (arr1)** | **j (arr2) = 3 - i** | **arr1 왼쪽** | **arr2 왼쪽** | **전체 왼쪽 (3개)** | **arr1 오른쪽** | **arr2 오른쪽** | **전체 오른쪽 (3개)** |
|:------------:|:--------------------:|:-----------:|:-----------:|:--------------:|:------------:|:------------:|:---------------:|
| 0            | 3                    | -           | [2, 4, 5]   | [2, 4, 5]      | [1, 3]       | [6]          | [1, 3, 6]       |
| 1            | 2                    | [1]         | [2, 4]      | [1, 2, 4]      | [3]          | [5, 6]       | [3, 5, 6]       |
| ✅2           | 1                    | [1, 3]      | [2]         | [1, 2, 3]      | -            | [4, 5, 6]    | [4, 5, 6]       |

여기서 항상 `i + j = halfLen`이 성립이 된다면 좌, 우 값의 수가 동일해지는 것을 표로 확인할 수 있다.

각 배열의 인덱스 관리 방법을 이해 했다면 다음 동작 과정은 쉽게 이해한다.

### 동작 과정 1️⃣
```java
	if (i < n && arr2[j - 1] > arr1[i]) {
    	iMin = i + 1;
   	} else if (i > 0 && arr1[i - 1] > arr2[j]) {
    	iMax = i - 1;
    }
```

초기화된 변수 `i`, `j`를 갖고 각 배열의 요소들의 값을 비교를 한다.     

처음으로 오는 조건문에서 `arr2[j - 1] > arr1[i]`을 비교한다.  이는 `arr1[]`배열에서 `i` 위치 파티션에서 우측값과 `arr2[]`배열 `j`위치의 파티션 기준으로 좌측 값을 비교를 한다.     

두 값을 비교를 하는 과정에서 `arr2[j - 1]`의 값이 `arr1[i]`보다 크다는 것은 아래와 같은 상황이다.
| **i (arr1)** | **j (arr2) = 3 - i** | **arr1 왼쪽** | **arr2 왼쪽** | **전체 왼쪽 (3개)** | **arr1 오른쪽** | **arr2 오른쪽** | **전체 오른쪽 (3개)** |
|:------------:|:--------------------:|:-----------:|:-----------:|:--------------:|:------------:|:------------:|:---------------:|
| 1            | 2                    | [1]         | [2, 4]      | [1, 2, 4]      | [3]          | [5, 6]       | [3, 5, 6]       |

즉 하나의 배열로 만들었을 떄, 전체 배열의 왼쪽 절반의 요소 중 최대값이 오른쪽 절반 요소 중 최소값보다 크다는 것을 의미한다.  그렇기 때문에 `i`에 1을 더해서 `arr1`의 파티션을 한 칸 옮겨 아래와 같이 값의 순서를 맞춰야 한다.
| **i (arr1)** | **j (arr2) = 3 - i** | **arr1 왼쪽** | **arr2 왼쪽** | **전체 왼쪽 (3개)** | **arr1 오른쪽** | **arr2 오른쪽** | **전체 오른쪽 (3개)** |
|:------------:|:--------------------:|:-----------:|:-----------:|:--------------:|:------------:|:------------:|:---------------:|
| 2            | 1                    | [1, 3]      | [2]         | [1, 2, 3]      | -            | [4, 5, 6]    | [4, 5, 6]       |

### 동작 과정 2️⃣

위 동작을 통해서 전체 배열을 중간을 기점으로 좌, 우 나누었을 때와 동일하게 나타났다면 이제 거의 다 끝났다.  그러면 이제 중간값만 추출하면 모든 동작은 끝나는 것이다.

중간값을 구하기 위해서는 좌, 우로 나누었을 때 좌측의 최대값과 우측의 최소값을 구하면 된다.

```java
    int maxOfLeft;
    if (i == 0) maxOfLeft = arr2[j - 1];
    else if (j == 0) maxOfLeft = arr1[i - 1];
    else maxOfLeft = Math.max(arr1[i - 1], arr2[j - 1]);

    if ((n + m) % 2 == 1) return maxOfLeft;
             
    int minOfRight;
    if (i == n) minOfRight = arr2[j];
    else if (j == m) minOfRight = arr1[i];
    else minOfRight = Math.min(arr1[i], arr2[j]);

    return (maxOfLeft + minOfRight) / 2.0;
```

위 코드에서 제일 상단에서 `i == 0`일 경우를 거르고 있다. 이는 `i`가 0일 때는 죄측에는 `halfLen`에 포함되지 않고 우측에 포함되고 있다는 것을 확인할 수 있다.  그렇기 때문에  `maxOfLeft = arr2[j - 1]`가 성립 된다.

해당 개념을 바탕으로 우측의 최소값을 찾아 두 값을 더해 나누면 두 배열의 중간값을 구할 수 있다.

지금까지 전체 배열의 길이가 짝수일 경우를 예를 들었다. 하지만 전체 배열의 길이가 홀수일 경우도 존재한다. 그렇기 때문에 홀수일 경우도 중간값을 찾아 반환하도록 조건문을 작성한다.
```java
    if ((n + m) % 2 == 1) return maxOfLeft;
```
