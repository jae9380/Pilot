# 나의 코드 계산 횟수 예측하기

계산 속도에 있어 컴퓨터와 인간 중 누가 더 빠를까를 생각해 보면, 대부분은 비교할 필요도 없이 컴퓨터가 훨씬 빠를 것이라고 말할 것이다. 실제로도 인간이 1시간이 걸릴 계산을 컴퓨터는 순식간에 끝내는 경우가 많다.

그러면 컴퓨터의 계산에는 한계가 없을까?

안타깝게도 그렇지 않다. 아무리 빠른 컴퓨터라도 연산 속도에는 분명한 한계가 존재한다. 예를 들어, 일반적인 가정용 컴퓨터는 1초에 약 10억 회의 연산을 수행할 수 있다고 알려져 있다. 하지만 효율이 좋지 않은 알고리즘을 사용하거나, 처리해야 할 데이터가 지나치게 많을 경우, 전체 연산 횟수가 1경(10¹⁶)을 쉽게 넘어서게 된다. 이러한 상황에서는 우리가 작성한 프로그램이 실제로 동작하더라도, 결과를 얻기까지 몇 시간, 혹은 며칠이 걸릴 수 있으며, 이는 사실상 ‘쓸모없는 프로그램’이 되어버리는 것이다.

따라서 우리는 프로그램을 작성하기 전에 “이 프로그램은 얼마나 많은 연산을 수행하는가?”, “결과를 얻기까지 얼마나 걸릴 것인가?“를 예측할 수 있어야 하며, 그 판단의 핵심이 바로 **시간 복잡도(Time Complexity)** 개념이다.

## 시간 복잡도, Time Complexity

프로그래밍에서 **시간 복잡도(Time Complexity)**는 **입력값의 크기(n)**에 따라서 알고리즘이 수행하는 연산의 횟수를 나타낸 것을 내포한다. 다시 말해서, 입력된 값의 크기가 클 수록 프로그램이 얼마나 오랜 시간이 걸리는지를 나타내는 지표이다.

시간 복잡도는 코드가 실행되는 **시간**을 측정한 것이 아닌, **연산 횟수의 증가 추세**를 분석한 것이라고 봐야 한다. 따라서 컴퓨터의 성능이나 프로그래밍 언어의 차이 같은 경우는 외부적인 요소와 무관하게 알고리즘 자체의 성능을 판단할 수 있게 된다.

시간 복잡도를 표기하는데 있어 주로 `Big-O` 표기법을 이용한다. (해당 부분은 나중에 다룰 예정)

이러한 개념을 바탕으로 시간 복잡도를 이용하면 다음과 같은 상황에서 이점을 챙길 수 있다.
* 시간 복잡도는 입력 크기에 따른 상대적인 성능 비교
* 대략적인 실행 시간을 예측하여 실행 전에 해결 가능 여부 판단
* 알고리즘의 효율성을 판단

이러한 시간 복잡도가 가져다 주는 이점들을 이용하여 내가 작성한 코드들이 반환해주는 과정에서 효율적인 알고리즘을 선택 하였는지를 판단할 수 있게 되며, 문제의 출제 의도나 개발의 의도에 적합한 코드를 작성할 수 있게 된다는 중요한 포인트가 된다.

## 시간 복잡도 표기
**`Big-O` 표기법**을 알아보기 전에 간단한 내용을 짚고 넘어가겠다.    

> 1 부터 2N까지의 정수를 모두 더한 값을 구할 때 연산 횟수는?

$$2N - 1$$

이처럼 간단한 문제의 경우, 정확한 연산 횟수를 직접 구하는 것이 가능하다. 하지만 현실의 프로그래밍 문제들은 이보다 훨씬 더 복잡한 경우가 많고, 연산 과정도 다양하기 때문에 정확한 횟수를 일일이 세는 것은 상당히 어렵고 비효율적이다.

또한, 실제로는 2N회와 3N회의 차이는 큰 의미가 없다. 대부분의 경우, 입력의 크기에 따라 얼마나 빠르게 연산 횟수가 증가하는가가 더 중요합니다.

그래서 우리는 “대략 N번 정도의 연산이 필요하다”처럼, 연산 횟수의 성장 추세를 기준으로 복잡도를 예측해야 한다. 이럴 때 사용하는 것이 바로 **`Big-O` 표기법**입니다.

### 란다우 표기법

// 란다우 표기법 설명

// 어떤 방법이 있는지 설명

#### Big - o 
// 개념 설명

// 수식을 란다우 표기법으로 변환 과정 설명

// * 간단한 예시 설명

## 실제 적용
* 문제 1
* 문제 2

## 병목 현상 분석 및 최적화

## Bonus 
// 문제01과 문제02의 시간 복잡도를 최적화 하기 위한 방법을 코드에 적용하고, 이전 코드와 시간 복잡도 차이를 Big O로 비교해본다.